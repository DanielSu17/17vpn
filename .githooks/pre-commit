#!/usr/bin/env python
# -*- coding: utf-8 -*-

import os
import re
import subprocess
import sys
import requests
import json
import yaml
from ruamel.yaml import YAML
import importlib

# python3 sys doesn't have setdefaultencoding
if hasattr(sys, 'setdefaultencoding'):
    reload(sys)
    sys.setdefaultencoding('utf-8')

# Compatible with python3
try:
    input = raw_input
except NameError:
    pass

modified = re.compile('^[MA]\s+envs\/(?P<env>(prod|sta|awssta|dev))\/(?P<app>(17app|wave))\/(?P<filename>.*)$')
access_token = 'BAf9qBQPVG.yA<b(q2xBF5gLhc5cGp5QF3JMu0'
api = {
    '17app': {
        'prod': 'https://api-dsa.17app.co',
        'sta': 'https://sta-api.17app.co',
        'dev': 'https://sta-api.17app.co',
    },
    'wave': {
        'prod': 'https://api.wave.com.tw',
        'sta': 'https://sta-api.wave.com.tw',
        'dev': 'https://sta-api.wave.com.tw',
    },
}
result, warning, syntax_error_count = 0, 0, 0


def query_yes_no(question, default="no"):

    valid = {"yes": True, "y": True, "ye": True,
             "no": False, "n": False}
    if default is None:
        prompt = " [y/n] "
    elif default == "yes":
        prompt = " [Y/n] "
    elif default == "no":
        prompt = " [y/N] "
    else:
        raise ValueError("invalid default answer: '%s'" % default)

    while True:
        sys.stdout.write(question + prompt)
        sys.stdin = open('/dev/tty')
        choice = input().strip().lower()
        if default is not None and choice == '':
            return valid[default]
        elif choice in valid:
            return valid[choice]
        else:
            sys.stdout.write("Please respond with 'yes' or 'no' "
                             "(or 'y' or 'n').\n")


def highlight(text, status):
    attrs = []
    colors = {
        'green': '32',
        'red': '31',
        'yellow': '33',
        'dark_gray': '90',
        'light_gray': '39'
    }
    if not sys.stdout.isatty():
        return text
    attrs.append(colors.get(status, 'red'))
    attrs.append('1')
    return '\x1b[%sm%s\x1b[0m' % (';'.join(attrs), text)


def system(*args, **kwargs):
    kwargs.setdefault('stdout', subprocess.PIPE)
    proc = subprocess.Popen(args, **kwargs)
    out, err = proc.communicate()
    return out, err


def main():
    global result
    # Stash any changes to the working tree that are not going to be committed
    subprocess.call(['git', 'stash', '-u', '--keep-index'],
                    stdout=subprocess.PIPE)

    tmp_files = {}
    out, err = system('git', 'status', '--porcelain')
    print(highlight("\n>>>>>>>> [{}]:".format(
        "Local Configs Syntax Checking"), 'green'))

    for line in out.splitlines():
        match = modified.match(str(line))
        if match:
            env = match.group('env')
            app = match.group('app')
            filename = match.group('filename')
            local_syntax_checker(
                "envs/{}/{}/{}".format(env, app, filename))
            tmp_files.setdefault(env, {})
            tmp_files[env].setdefault(app, [])
            tmp_files[env][app].append(filename)

    if syntax_error_count == 0:
        print(highlight("\n>>>>>>>> [{}]:".format(
            "Remote Configs Checking"), 'green'))
        for env, apps in tmp_files.items():
            if len(apps) >= 1:
                print(highlight("# <<{}>> ".format(env.upper()), 'green'))
            for app, fs in apps.items():
                remote_check_configs(env, app, fs)
        skip_or_abort()
    else:
        result = 1

    print(highlight("\n>>>>>>>> [{}]:".format(
            "Author Email Checking"), 'green'))
    author_info, err = system("git", "var", "GIT_AUTHOR_IDENT")
    author_email_checker(author_info)

    # Unstash changes to the working tree that we had stashed
    subprocess.call(['git', 'reset', '--hard'], stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE)
    subprocess.call(['git', 'stash', 'pop', '--quiet', '--index'],
                    stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    sys.exit(result)


def local_syntax_checker(filepath):
    global syntax_error_count
    with open(filepath, 'r') as stream:
        try:
            if filepath.endswith('.yaml') or filepath.endswith('yml'):
                # YAML(typ='safe') accomplishes the same as what yaml.safe_load() did
                yamll=YAML(typ='safe')
                yamll.load(stream)
            if filepath.endswith('.json'):
                json.load(stream)
            print("  {} ==> {}".format(filepath, highlight('succeed', 'green')))
        except yaml.YAMLError as exc:
            print("  {} ==> failure ({})".format(filepath, highlight(exc, 'red')))
            syntax_error_count += 1
        except ValueError as exc:
            print("  {} ==> failure ({})".format(filepath, highlight(exc, 'red')))
            syntax_error_count += 1
        finally:
            stream.close()


def remote_check_configs(env, app, files_list):
    headers = {'accesstoken': access_token}
    metadata = {}
    files = {}
    for idx, f in enumerate(files_list):
        key = "file%s" % str(idx + 1)
        files[key] = open("envs/%s/%s/%s" % (env, app, f))
        metadata[key] = {"path": "{}/{}".format(app, f)}

    rp_metadata = {"metadata": json.dumps(metadata)}
    response = requests.request("POST",
                                "%s/api/v1/config/check" % api[app][env],
                                headers=headers,
                                data=rp_metadata,
                                files=files)
    jsonObject = json.loads(response.text)
    print(display_response(env, jsonObject))
    set_result(jsonObject)


def author_email_checker(author_info):
    global result
    print(author_info)
    if not re.match(r".*<.+@17\.(live|media)>.*", author_info):
        print(highlight("Failed GIT_AUTHOR_IDENT: {}".format(author_info), 'red'))
        print("You should use your slack email (xxx@17.media | xxx@17.live) to commit,")
        print("in order to tag you in slack when build failed.")
        print("Set your email by using: $ git config user.email xxx@17.media")
        result = 1


def skip_or_abort():
    global result
    if (result != 1
        and warning == 1
            and (query_yes_no("\nHas configs Warning do you want continue?") == False)):
        result = 1


def set_result(messages):
    global warning
    global result
    if 'error' in messages and len(messages['error']) > 0:
        result = 1
    if 'warning' in messages and len(messages['warning']) > 0:
        warning = 1


def display_response(env, response):
    s = ""
    for status in response:
        for filepath in response[status]:
            s += highlight("  [{}]\n".format(status.upper()),
                           status_color(status))
            s += "    <envs/{}/{}>:\n".format(env, filepath)
            s += pretty_message(filepath, response[status][filepath])
    return s


def status_color(status):
    if status == 'error':
        return 'red'
    else:
        return 'yellow'


def pretty_message(status, messages):
    s = ""
    for idx, text in enumerate(messages):
        first_line = 1
        for line in text.splitlines():
            str_chr = "  "
            if first_line == 1:
                str_chr, first_line = "- ", 0
            s += highlight("      {}{}\n".format(str_chr,
                                                 str(line.encode('utf-8'))),
                                                 line_color(idx))
    return s


def line_color(idx):
    if idx % 2 == 0:
        return 'light_gray'
    else:
        return 'dark_gray'

if __name__ == '__main__':
    main()
